#!/usr/bin/env python
#
# Copyright (c) STMicroelectronics 2012
#
# This file is part of ptimeout.
#
# ptimeout is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License v2.0
# as published by the Free Software Foundation
#
# ptimeout is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# v2.0 along with ptimeout. If not, see <http://www.gnu.org/licenses/>.
#
#
# Usage: get usage with ptimeout -h
#

import sys, os
import subprocess, signal, errno, argparse, time

VERSION="1.0.0"
GRP_ENVVAR = "PTIMEOUT_GRP"

class ExitCodes:
    """ Exit codes used to feedback the parent process.
    This codes are aligned with the coreutils timeout implementation.
    Note that, as for coreutils, in case of termination with signal 9
    the TIMEOUT code can't be returned, the exit code will be (128+9).
    """
    TIMEDOUT = 124  # job timed out
    CANCELED = 125  # internal error
    CANNOT_INVOKE = 126  # error executing job
    ENOENT = 127  # couldn't find job to exec

class LocalArgumentParser(argparse.ArgumentParser):
    """
    Overrides ArgumentParser for exiting with the correct code on error.
    """
    def __init__(self, prog=None, description=None):
        super(LocalArgumentParser, self).__init__(
            prog=prog, description=description)

    def parse_args(self):
        args = super(LocalArgumentParser, self).parse_args()
        return self.process_args(args)
        

    def get_signum(self, sigstr):
        """
        Return a signal number from a number or a symbolic string.
        """
        try:
            signum = int(sigstr)
        except:
            try:
                signum = eval("signal.SIG" + sigstr)
            except:
                self.exit(1, ("%s: error: invalid signal spec: %s\n"
                              % (self.prog, sigstr)))
        return signum

    def process_args(self, args):
        """
        Process parsed args into suitable form after some checks.
        """
        args.signal = self.get_signum(args.signal)
        args.catch_signals = set(
            map(self.get_signum, args.catch_signals.split(",")))

        if not args.format in ["pid", "short", "long"]:
            self.exit(1, "%s: error: unknown list format: %s\n" %
                      (self.prog, args.format))
        if args.list != None:
            return args
            
        if args.duration == None:
            self.exit(1, "%s: error: missing duration argument\n" % self.prog)
        if args.command == None:
            self.exit(1, "%s: error: missing command\n" % self.prog)
        return args

    def exit(self, status=0, message=None):  # pragma: uncovered
        """ Always exit with status CANCELED on error. """
        if status != 0:
            status = ExitCodes.CANCELED
        super(LocalArgumentParser, self).exit(status, message)


parser = LocalArgumentParser(
    prog="ptimeout",
    description="ptimeout utility"
    ", stops the given COMMAND after DURATION seconds.")

parser.add_argument("-v", "--version",
                    help="output version string",
                    action="version",
                    version="ptimeout version " + VERSION)
parser.add_argument("-d", "--debug",
                     dest="debug",
                     help="debug mode",
                     action="store_true")
parser.add_argument("-s", "--signal",
                     default="TERM",
                     help="signal to be sent for terminating the COMMAND. Default: TERM")
parser.add_argument("-k", "--kill-after",
                     type=int, default=10,
                     help="delay for actually killing (SIGKILL) the COMMAND. Default: 10")
parser.add_argument("-c", "--catch-signals",
                     default="INT,TERM,QUIT",
                     help="signals caught by timeout and propagated. Default INT,TERM,QUIT")
parser.add_argument("-l", "--list",
                     type=int,
                     help="list the processes in the given timeout session pid")
parser.add_argument("-f", "--format",
                     default="short",
                     help="format of the process list, one of: pid, short, long. Default: short")
parser.add_argument("duration",
                    nargs='?',
                    type=int, default=0,
                    help="duration in seconds before the timeout")
parser.add_argument("command",
                    nargs='?', default=None,
                    help="command to be executed")
parser.add_argument("arguments",
                    nargs=argparse.REMAINDER,
                    help="command arguments")

class Monitor():
    """ Monitor class for interrupting a process after a given timeout. """
    def __init__(self, args):
        """ Constructor, arguments are stored into the args object. """
        self.args = args
        self.proc = None
        self.group = None

    class TimeoutException(Exception):
        """ Timeout exception used by the alarm to notify the monitor. """
        pass

    class TerminateException(Exception):
        """ Terminate exception raised by trmination signals. """
        def __init__(self, signum):
            self.signum = signum

    def timeout_grps(self, pid):
        """
        Get the timeout groups for the given process, it is available through
        the GRP_ENVVAR (see definition above) envvar of the process.
        Returns the list of timeout groups for the process or [].
        """
        try:
            with open("/proc/%d/environ" % pid) as f:
                env_vars = f.read()
        except IOError:
            # Can't read, not accessible
            return []
        env_list = env_vars.strip().split('\0')
        for env in env_list:
            index = env.find(GRP_ENVVAR + "=")
            if index == 0:
                return map(int, env[(len(GRP_ENVVAR) + 1):].split(':'))
        return []

    def all_process_list(self):
        """
        Returns all visible processes pids.
        """
        def filter_is_pid(pidstr):
            try:
                pid = int(pidstr)
                return True
            except:
                return False

        for root, dirs, files in os.walk("/proc"):
            pids = map(int, filter(filter_is_pid, dirs))
            break
        return pids

    def sub_processes(self):
        """
        Construct the full list of process for this monitor.
        """
        def all_grp_processes(grp, process_list):
            """ Get all processes that match the monitor group. """
            def filter_grp(pid):
                return grp in self.timeout_grps(pid)
            return filter(filter_grp, process_list)

        processes = self.all_process_list()
        grp_processes = all_grp_processes(self.group, processes)
        return grp_processes

    @staticmethod
    def timeout_handler(signum, frame):
        """ Handler for the alarm. """
        raise Monitor.TimeoutException()

    @staticmethod
    def terminate_handler(signum, frame):
        """ Handler for termination through signals. """
        raise Monitor.TerminateException(signum)

    @staticmethod
    def interrupt_handler(signum, frame):  # pragma: uncovered
        """ Handler for signals that require immediate exit. """
        print >>sys.stderr, \
            "ptimeout: interrupted by signal %d" % signum
        sys.exit(128 + signum)

    def send_signal(self, sig):
        """
        Terminates the monitored processes with the given signal.
        All processes in the monitor hierarchy will receive the signal.
        In order to avoid race conditions when a process is created
        after the list of processes in the group is constructed, we
        iterate until no more processes in the group is found.
        Note that in the main monitor loop an alarm is setup in the
        case where the signal is not SIGKILL, thus in practice the
        loop will always be exited.
        """
        def filter_monitor(proc):
            return proc != self.group

        while True:
            to_be_killed = filter(filter_monitor, self.sub_processes())
            if not to_be_killed: break
            if self.args.debug:
                print >>sys.stderr, "ptimeout: sending processes signal %d:" % sig
                self.print_pids(to_be_killed, fmt="short", output=sys.stderr)
            for proc in to_be_killed:
                try:
                    os.kill(proc, sig)
                except OSError, e:
                    # Process already killed
                    pass
            time.sleep(1)

    def print_pids(self, pids, fmt="short", output=sys.stdout):
        assert(fmt in ["pid", "short", "long"])
        for pid in pids:
            try:
                with open("/proc/%d/cmdline" % pid) as f:
                    cmd_args = f.read().strip().split('\0')
            except IOError:
                # Can't read, not accessible
                continue
            if fmt == "pid":
                print >>output, "%d" % (pid)
            if fmt == "short":
                print >>output, "%d %s" % (pid, cmd_args[0])
            elif fmt == "long":
                print >>output, "%d %s" % (pid, " ".join(cmd_args))
            
    def run(self):
        """
        Runs the monitor and monitored process.
        This method returns the exit code to be passed to sys.exit.
        """

        # Show processes for the given group
        if args.list != None:
            self.group = args.list
            self.print_pids(self.sub_processes(), args.format)
            sys.exit(0)

        # Set the timeout group to the monitor pid
        self.group = os.getpid()
        grps = os.environ.get(GRP_ENVVAR, None)
        os.environ[GRP_ENVVAR] = (str(self.group) if not grps else
                                  ':'.join((str(self.group), grps)))

        # Install default handler for ^C
        if signal.SIGINT not in self.args.catch_signals:
            signal.signal(signal.SIGINT, self.interrupt_handler)

        # Install termination handler for all requested signals
        for signum in self.args.catch_signals:
            signal.signal(signum, self.terminate_handler)
            
        # Launch monitored process
        command_args = [self.args.command] + self.args.arguments
        try:
            self.proc = subprocess.Popen(command_args)
        except OSError, e:
            print >>sys.stderr, "ptimeout: error: failed to run " \
                "command: %s : %s" % (e.strerror, " ".join(command_args))
            if e.errno == errno.ENOENT:
                return ExitCodes.ENOENT
            else:
                return ExitCodes.CANNOT_INVOKE

        # Install timer through alarm
        signal.signal(signal.SIGALRM, self.timeout_handler)
        signal.alarm(self.args.duration)

        # Monitoring loop
        completed = False
        terminated = False
        killed = False
        interrupted_by = None
        while not completed:
            try:
                if killed:
                    self.send_signal(9)
                elif terminated:
                    signal.alarm(self.args.kill_after)
                    self.send_signal(self.args.signal)
                elif interrupted_by != None:
                    signal.alarm(self.args.kill_after)
                    self.send_signal(interrupted_by)
                code = self.proc.wait()
                completed = True
            except self.TimeoutException:
                if interrupted_by == None:
                    if self.args.debug and not terminated:
                        print >>sys.stderr, \
                            "ptimeout: command timeout: %s" % command_args[0]
                    if self.args.signal == 9 or terminated:
                        if self.args.debug:
                            print >>sys.stderr, \
                                "ptimeout: sending SIGKILL: %s" % command_args[0]
                        
                        killed = True
                    else:
                        if self.args.debug:
                            print >>sys.stderr, "ptimeout: " \
                                "sending signal " + str(self.args.signal)
                        terminated = True
                else:
                    if self.args.debug:
                        print >>sys.stderr, \
                            "ptimeout: sending SIGKILL: %s" % command_args[0]
                        
                    killed = True
            except self.TerminateException, e:
                if self.args.debug:
                    print >>sys.stderr, \
                        "ptimeout: interrupted by signal: %d " % e.signum
                interrupted_by = e.signum
        if interrupted_by == None:
            if killed:
                print >>sys.stderr, "Killed after timeout: %d: %s" % \
                    (os.getpid(), " ".join(command_args))
                return ExitCodes.TIMEDOUT
            elif terminated:
                print >>sys.stderr, "Terminated after timeout: %d: %s" % \
                    (os.getpid(), " ".join(command_args))
                return ExitCodes.TIMEDOUT
        else:
            if killed:
                print >>sys.stderr, "Killed by signal %d: %d: %s" % \
                    (interrupted_by, os.getpid(), " ".join(command_args))
            else:
                print >>sys.stderr, "Terminated by signal %d: %d: %s" % \
                    (interrupted_by, os.getpid(), " ".join(command_args))
            return 128 + interrupted_by
        return code

args = parser.parse_args()
sys.exit(Monitor(args).run())
